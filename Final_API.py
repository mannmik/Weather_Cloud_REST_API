from google.appengine.ext import ndb
import webapp2
import json
import requests
import requests_toolbelt.adapters.appengine

requests_toolbelt.adapters.appengine.monkeypatch()

'''
Mike Mann
Final Project
Cloud Only Rest API

Followed these links to install and use the third party requests library. it is right from google app engine. 
https://cloud.google.com/appengine/docs/standard/python/issue-requests
https://cloud.google.com/appengine/docs/standard/python/tools/using-libraries-python-27#installing_a_library
Used class lectures and stackoverflow as references for this project

'''

userOne = "fbeda4b0df65d1c0e5ca0673a2be58ff"                                        #already authorized user one
userTwo = "6a66e409d70296aa813d2704cc31e4c0"                                        #already authorized user two
mainUrl = "http://api.openweathermap.org/data/2.5/weather?q="                       #main url of the westher api
faren = "&units=imperial"                                                           #gets farenheit from weather api
preTok = "&APPID="                                                                  #part of the url for the user token in weather api


class User(ndb.Model):
    id = ndb.StringProperty()                                                       #user ID will store a unique key generated by this api with google app engine key property
    username = ndb.StringProperty()                                                 #username for the user account
    email = ndb.StringProperty()                                                    #required user email upon creation of a new user
    watchList = ndb.JsonProperty(repeated=True)                                     #holds a list of our desired trip locations. A watch list of specific locations

class Location(ndb.Model):
    id = ndb.StringProperty()                                                       #unique id of a location
    nickname = ndb.StringProperty()                                                 #user defined nickaname or note for this location
    cityName = ndb.StringProperty()                                                 #city name of the location
    country = ndb.StringProperty()                                                  #country code i.e. us or uk
    currentTemp = ndb.FloatProperty()                                               #temperatures of the location with the matching city name and contry code
    minTemp = ndb.FloatProperty()
    maxTemp = ndb.FloatProperty()

class MainPage(webapp2.RequestHandler):
    def get(self):
        self.response.write("Mike Mann Cloud Only Rest API")

class UserHandler(webapp2.RequestHandler):                                          
    def get(self, id=None):
        if id:                                                                      #if an id was in the path
            try:
                usr = ndb.Key(urlsafe=id).get()                                     #return the user account with the matching id and return the entity as an object
                usr_dict = usr.to_dict()
                usr_dict['self'] = '/user/' + usr.id
                self.response.write(json.dumps(usr_dict))
            except:
                self.response.write("ERROR: Unable to find a user with that id.")
                self.abort(400)
        else:
            usrKeys = User.query().fetch(keys_only=True)                            #if there was no id in the path then return a list of all user entities
            numUsr = len(usrKeys)
            query = User.query().fetch(numUsr)
            objList = []                                                            #stores a list of dicts 
            for i in query:
                tempUsr = i
                tempDict = tempUsr.to_dict()
                objList.append(tempDict)
                
            self.response.write(json.dumps(objList))                                #return our list of user account dicts
    
    def post(self):
        usrInfo = json.loads(self.request.body)                                     #gather the user info form the body of the request
        newUsr = User()
        if usrInfo['email']:                                                        #create a new user entity and update its email and username with the ones passed in the body
            newUsr.email = usrInfo['email']

            if usrInfo['username']:
                newUsr.username = usrInfo['username']
            else:
                newUsr.username = usrInfo['email']
        
            newUsr.put()                                                            #add the new user
            newUsr.id = newUsr.key.urlsafe()
            newUsr.put()
            usrDict = newUsr.to_dict()
            
            self.response.write(json.dumps(usrDict))                                #return the user object in the body
        else:
            self.response.write("ERROR: New user account must contain an 'email' field.")
            self.abort(400)
    
    def patch(self, id=None):
        if id:
            try:
                usrInfo = json.loads(self.request.body)                             #if there was an id in the path load the info in the body of the request
                usrToEdit = ndb.Key(urlsafe=id).get()                               #get the matching user
                if usrInfo['username']:
                    usrToEdit.username = usrInfo['username']                        #update the username of the user account
                    usrToEdit.put()
                    usrDict = usrToEdit.to_dict()
                    self.response.write(json.dumps(usrDict))                        #return the updated user account
                else:
                    self.abort(400)
            except:
                self.abort(400)
        else:
            self.abort(400)


    def delete(self, id=None):
        if id:
            try:
                usrToRemove = ndb.Key(urlsafe=id).get()                             #if there was id in the path, delete that user account otherwise do nothing
                usrToRemove.key.delete()
                self.response.write("User was successfully deleted.")
            except:
                self.abort(400)

class LocationHandler(webapp2.RequestHandler):
    def post(self, token=None):
        if token:                                                                   #if the user has a token then they can add a location because we must gather weather info
            locationInfo = json.loads(self.request.body)                            #load the body of the request
            newLocation = Location()
            if locationInfo['cityName']:
                newLocation.cityName = locationInfo['cityName']                     #update the city name, country, and nickname
                if locationInfo['country']:
                    newLocation.country = locationInfo['country']
                else:
                    self.abort(400)
                if locationInfo['nickname']:
                    newLocation.nickname = locationInfo['nickname']
                req = requests.get(mainUrl + newLocation.cityName + "," + newLocation.country + faren + preTok + token)     #request to the weather api
                weatherInfo = req.json()
                newLocation.currentTemp = weatherInfo['main']['temp']               #update the location temp info with the returned body of the weather api
                newLocation.minTemp = weatherInfo['main']['temp_min']
                newLocation.maxTemp = weatherInfo['main']['temp_max']
                newLocation.put()
                newLocation.id = newLocation.key.urlsafe()
                newLocation.put()                                                   #add our new location 
                locDict = newLocation.to_dict()
                
                self.response.write(json.dumps(locDict))                            #return the location object
            else:
                self.abort(400)
    
    def get(self, token=None, id=None):
        if token and id:                                                            #if there was a token and id return the location matching the id
            try:
                loc = ndb.Key(urlsafe=id).get()
                loc_dict = loc.to_dict()
                
                self.response.write(json.dumps(loc_dict))
            except:
                self.abort(400)
        elif token:                                                                #or return a list of all the locations
            locKeys = Location.query().fetch(keys_only=True)
            numLoc = len(locKeys)
            query = Location.query().fetch(numLoc)
            objList = []
            for i in query:
                tempLoc = i
                tempDict = tempLoc.to_dict()
                objList.append(tempDict)
               
            self.response.write(json.dumps(objList))
        else:
            self.abort(400)
    
    def delete(self, token=None, id=None):
        if token and id:                                                            #delete a location matching the id
            try:
                locationToRemove = ndb.Key(urlsafe=id).get()
                locationToRemove.key.delete().
                usrKeys = User.query().fetch(keys_only=True)
                numUsr = len(usrKeys)
                query = User.query().fetch(numUsr)
                for i in query:                                                     #remove the location from any watch list it may be in.
                    tempUsr = i 
                    if id in tempUsr.watchList:
                        tempUsr.watchList.remove(id)
                        tempUsr.put()
                        self.response.write("location removed.\n")
                self.response.write("Location was successfully deleted.")
            except:
                self.abort(400)
        else:
            self.abort(400)
    
    def patch(self, token=None, id=None):
        if token and id:                                                            #update or edit a locations nickname
            try:
                locationInfo = json.loads(self.request.body)                        #load body of request
                if locationInfo['nickname']:
                    locationToEdit = ndb.Key(urlsafe=id).get()
                    locationToEdit.nickname = locationInfo['nickname']
                    locationToEdit.put()                                            #update locatin with new nickname
                    locDict = locationToEdit.to_dict()
                    self.response.write(json.dumps(locDict))                        #return the updated object
            except:
                self.abort(400)
        else:
            self.abort(400)
    
    def put(self, token=None, id=None):
        if token and id:                                                            #replaces a location entity but keeps same id
            try:
                locationInfo = json.loads(self.request.body)                        #load body of request
                locationToEdit = ndb.Key(urlsafe=id).get()                          #get the location specified by id and update required fields
                if locationInfo['cityName'] and locationInfo['country'] and locationInfo['nickname']:
                    locationToEdit.cityName = locationInfo['cityName']
                    locationToEdit.country = locationInfo['country']
                    locationToEdit.nickname = locationInfo['nickname']
                else:
                    self.abort(400)
                req = requests.get(mainUrl + locationInfo['cityName'] + "," + locationInfo['country'] + faren + preTok + token)
                weatherInfo = req.json()
                locationToEdit.currentTemp = weatherInfo['main']['temp']            #now we must gather the weather for this new location replacing the old one
                locationToEdit.minTemp = weatherInfo['main']['temp_min']
                locationToEdit.maxTemp = weatherInfo['main']['temp_max']
                locationToEdit.put()
                locDict = locationToEdit.to_dict()
                locDict['self'] = '/location/' + locationToEdit.id
                self.response.write(json.dumps(locDict))                            #return the new location object
            except:
                self.abort(400)

    
class ListHandler(webapp2.RequestHandler):
    def post(self, token=None, id=None):
        if token and id:                                                            #adds the location mathcing the id to the authorized user account watchlist
            try:
               userInfo = json.loads(self.request.body)
               if userInfo['id']:
                   usrID = userInfo['id']
                   usr = ndb.Key(urlsafe=usrID).get()
                   if usr.username == "userOne" and token == userOne:
                        usr.watchList.append(id)
                        usr.put()
                   elif usr.username == "userTwo" and token == userTwo:
                       usr.watchList.append(id)
                       usr.put()
            except:
                self.abort(400)
        else:
            self.abort(400)
    
    def get(self, token=None):
        if token == userOne or token == userTwo:                                    #return the watchlist of the authorized user
            usrKeys = User.query().fetch(keys_only=True)
            numUsr = len(usrKeys)
            query = User.query().fetch(numUsr)
            for i in query:
                tempUsr = i
                if tempUsr.username == "userOne" and token == userOne:
                    usrList = tempUsr.watchList
                    self.response.write(usrList)  
                elif tempUsr.username == "userTwo" and token == userTwo:
                    usrList = tempUsr.watchList
                    self.response.write(usrList)  
        else:
            self.abort(400)                                                                             
        
    def delete(self, token=None, id=None):
        if token and id:                                                           #delete  single location from a specified user list
            try:
                usrKeys = User.query().fetch(keys_only=True)
                numUsr = len(usrKeys)
                query = User.query().fetch(numUsr)
                for i in query:
                    
                    tempUsr = i
                    if tempUsr.username == "userOne" and token == userOne:
                        if id in tempUsr.watchList:
                            tempUsr.watchList.remove(id)
                            tempUsr.put()
                            self.response.write("location removed.\n")
                        elif tempUsr.username == "userTwo" and token == userTwo:
                            tempUsr.watchList.remove(id)
                            tempUsr.put()
                            self.response.write("location removed.\n")
            except:
                self.response.write("error")
               
        elif token:                                                                   #delete an entire wishlist for a user
            if token == userOne or token == userTwo:
                usrKeys = User.query().fetch(keys_only=True)
                numUsr = len(usrKeys)
                query = User.query().fetch(numUsr)
                for i in query:
                    tempUsr = i
                    if tempUsr.username == "userOne" and token == userOne:
                        tempUsr.watchList[:] = []                                      #used stackoverflow.com/questions/1400608/how-to-empty-a-list-in-python for help
                        tempUsr.put()
                          
                    elif tempUsr.username == "userTwo" and token == userTwo:
                        tempUsr.watchList[:] = []
                        tempUsr.put()  


            
#enables patch request
allowed_methods = webapp2.WSGIApplication.allowed_methods
new_allowed_methods = allowed_methods.union(('PATCH',))
webapp2.WSGIApplication.allowed_methods = new_allowed_methods

app = webapp2.WSGIApplication([('/', MainPage),
                                ('/user', UserHandler),
                                ('/user/([\w-]+)', UserHandler),
                                ('/location/([\w-]+)', LocationHandler),
                                ('/location/([\w-]+)/([\w-]+)', LocationHandler),
                                ('/user/([\w-]+)/watchlist/([\w-]+)', ListHandler),
                                ('/user/([\w-]+)/watchlist', ListHandler)
                                ],
                                debug=True)
